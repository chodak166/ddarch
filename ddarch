#!/bin/bash
## $SCRIPT_NAME v$SCRIPT_VERSION
##
## A dd wrapper script with .img file archiving features.
##
## Usage: $SCRIPT_FILENAME [command] [options]
##
## Commands:
##
##
## archive [default]                 shrink, truncate and compress image file; clone first if the input is a block device
## Options:
##   -i, --input [file]              input image file or block device
##   -o, --output [file]             output file, defaults to 'image-<yyyy-mm-dd>.<ext>'
##   -d, --dd-args [string]          additional dd arguments
##   -a, --arch-type [string]        archive type: tgz, zip, 7z, none
##   -n, --name [string]             replace "image" prefix of the output file with the given name
##   --shrink-tail [bytes]           additional empty space left in the shrunk partition
##   --truncate-tail [bytes]         additional empty space left in the truncated image
##   --no-resize                     do not resize the last partition
##   --no-truncate                   do not truncate the image
##   --no-zero                       do not fill empty space with zeros
##   --no-compress                   do not compress the image
##
##
## restore                           copy the image to the device and extend the last partition; decompress first if the input is an archive
## Options:
##   -i, --input [file]              input .img file or an archive (tar.gz, tgz, zip, 7z)
##   -o, --output [device]           target block device
##   -d, --dd-args [string]          additional dd arguments
##   --no-extend                     do not extend the last prtition to fit the target device size
## 
## 
## Global options:
##   -V, --verbose                  print the commands being executed and additional information
##   -q, --quiet                    do not print any output
##   -h, --help                     Display this message
##   -v, --version                  Display script version
##
## 
## Examples:
## 
## Create an archive from block device (clone, shrink, fill with zeroes, truncate, compress):
## $SCRIPT_FILENAME --name myimage -i /dev/sdc
##
##

#===========================================

SCRIPT_NAME=ddarch
SCRIPT_FILENAME=$(basename "$0")
SCRIPT_VERSION=0.1.0
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

set -e          # exit on command errors (so you MUST handle exit codes properly!)
set -o pipefail # capture fail exit codes in piped commands
set -x         # execution tracing debug messages


#todo: use as an argument
TMP_MOUNT_DIR=/tmp/ddarch.mnt.$(date +%s)

commandName=archive
input=
output=
ddArgs=
outputBaseName=image
shrinkTailSize=$((1024 * 1024)) # 1M
truncateTailSize=$((1024 * 1024)) # 1M
archType=7z
noResize=false
noTruncate=false
noZero=false
noCompress=false
noExtend=false
quiet=false
verbose=false

#===========================================


function usage {
    [ "$*" ] && echo "$0: $*"
    sed -n '/^##/,/^$/s/^## \{0,1\}//p' "$SCRIPT_DIR/$SCRIPT_FILENAME" |
  sed "s/\$SCRIPT_NAME/$SCRIPT_NAME/g" |
  sed "s/\$SCRIPT_FILENAME/$SCRIPT_FILENAME/g" |
  sed "s/\$SCRIPT_VERSION/$SCRIPT_VERSION/g"
    
    exit 2
} 2>/dev/null


function main {
    readCommandArg $1
    readOptions "$@"
    run
}

readCommandArg()
{
  arg=$1
  firstChar=${arg:0:1}

  if [ "$firstChar" != "-" ] && [ ! -z "$arg" ]; then
    commandName=$arg
    shift
  fi
}

readOptions()
{
    if [ $# -eq 0 ]; then
      usage;
    fi
    
    while [ $# -gt 0 ]; do
      case $1 in
        ('-h'|'--help')
          usage 2>&1;;
        ('-v'|'--version')
          echo "$SCRIPT_NAME v$SCRIPT_VERSION"
          exit 0;;
        ('-i'|'--input')
          shift
          input="$1";;
        ('-o'|'--output')
          shift
          output="$1";;
        ('-d'|'--dd-args')
          shift
          ddArgs="$1";;
        ('-n'|'--name')
          shift
          outputBaseName="$1";;
        ('--shrink-tail')
          shift
          shrinkTailSize="$1";;
        ('--truncate-tail')
          shift
          truncateTailSize="$1";;
        ('--no-resize')
          noResize=true;;
        ('--no-truncate')
          noTruncate=true;;
        ('--no-zero')
          noZero=true;;
        ('--no-compress')
          noCompress=true;;
        ('--no-extend')
          noExtend=true;;
        ('--quiet')
          quiet=true;;
        ('--verbose')
          verbose=true;;
        ('--')
          shift
          break;;
        ('-'*)
          echo -e "\n$0 $1: unknown option. Use --help to learn more.\n"
          exit 3
          break;;
        (*)
          break;;
      esac

      shift
    done
}

#===========================================


function run 
{
  :
}

hasExtendedPartition()
{
  local image="$1"
  if $(fdisk -l "$image" -o Type | grep -q 'LBA'); then
    echo true
  else
    echo false
  fi
}

getLastPartitionOffset()
{
  local image="$1"
  local offset=$(fdisk -l "$image" -o Start | tail -n 1)
  echo $(trim "$offset")
}

getLastPartitionSize()
{
  local image="$1"
  local size=$(fdisk --bytes -l -o Size --bytes "$image" | tail -n1)
  echo $(trim "$size")
}

shrinkLastPartition()
{
  local image="$1"
  local tailSize="$2"
  if [ -z "$tailSize" ]; then 
    tailSize=$shrinkTailSize; 
  fi
  
  local sectorSize=$(getSectorSize "$image")
  local offsetSectors=$(getLastPartitionOffset "$image")
  local offsetBytes=$[$offsetSectors * $sectorSize]
  
  local loDevice=$(losetup -f)
  
  losetup -L -o $offsetBytes $loDevice "$image"
  e2fsck -f $loDevice > /dev/null 2>&1 ||:
  
  local blockSize=$(getBlockSize $loDevice)
  local minBlocks=$(estimateBlocksAfterShrink $loDevice)
  local minBlocks=$[$minBlocks + $tailSize / $blockSize]
  local newFsSize=$[$blockSize * $minBlocks]
  local newEnd=$[$offsetBytes + $newFsSize]
  
  resize2fs $loDevice $minBlocks > /dev/null 2>&1 || echo "Error while resizing $loDevice to $minBlocks blocks"
  losetup -d $loDevice

  partNumber=$(getLastPartitionNumber "$image")
  echo Yes | parted "$image" ---pretend-input-tty unit B resizepart $partNumber ${newEnd}B >/dev/null 2>&1 
}

fillWithZeros()
{
  local image="$1"
  local sectorSize=$(getSectorSize "$image")
  
  local offsets=( $(getStartOffsets "$image") )
  for offset in ${offsets[*]}
  do
    local offsetBytes=$[$sectorSize * $offset]
    local loDevice=$(losetup -f)
    losetup -L -o $offsetBytes $loDevice "$image"
    mkdir -p $TMP_MOUNT_DIR
    mount $loDevice $TMP_MOUNT_DIR
    
    pushd $TMP_MOUNT_DIR >/dev/null
    local space=$(getAvailableSpace $TMP_MOUNT_DIR)
    local zerosFile="$TMP_MOUNT_DIR/zeros.bin"
    head -c $space /dev/zero > "$zerosFile"
    sync
    rm "$zerosFile"
    popd >/dev/null
    
    umount "$TMP_MOUNT_DIR"
    rmdir "$TMP_MOUNT_DIR"
    losetup -d $loDevice
    
  done
}

truncateImage()
{
  local image="$1"
  local tailSize="$2"
  if [ -z "$tailSize" ]; then 
    tailSize=$truncateTailSize; 
  fi
  
  local endSector=$(getEndSector "$image")
  local sectorSize=$(getSectorSize "$image")
  local isGpt=$(hasGptLayout "$image")
  
  if [ $isGpt = true ]; then
    local offsets=( $(getStartOffsets "$image") )
    local backupSize=$[$sectorSize * ${offsets[0]}]
    local tailSize=$[$tailSize + $backupSize]
  else
    local tailSize=$[$tailSize + $sectorSize]
  fi
  

  local trSize=$[$endSector * $sectorSize + $tailSize]

  truncate --size $trSize "$image"
  
  if [ $isGpt = true ]; then
    sgdisk -e "$image" >/dev/null 2>&1
  fi
}

restoreImage()
{
  image="$1"
  device=$2
  dd if="$image" of=$device status=progress
  
  isGpt=$(hasGptLayout $device)
  if [ $isGpt = true ]; then
    sgdisk -e $device > /dev/null 2>&1
  fi
  
  lastPartitionNum=$(getLastPartitionNumber $device)
  parted --script $device "resizepart $lastPartitionNum -1"
}

getBlockCount()
{
  local device=$1
  local value=$(dumpe2fs -h $device 2> /dev/null | grep 'Block count' | awk '{print $3}')
  echo $(trim "$value")
}

getBlockSize()
{
  local device=$1
  local value=$(dumpe2fs -h $device 2> /dev/null | grep 'Block size' | awk '{print $3}')
  echo $(trim "$value")
}

getSectorSize()
{
  local device=$1
  local value=$(fdisk -l "$image" | grep 'Sector size' | awk '{print $(NF-4)}')
  echo $(trim "$value")
}

estimateBlocksAfterShrink()
{
  local device=$1
  local value=$(resize2fs -P $device 2>/dev/null | awk '{print $NF}')
  echo $(trim "$value")
}

getLastPartitionNumber()
{
  local image="$1"
  local value=$(parted --script "$image" print | grep "." | tail -1 | awk '{print $1}')
  echo $value
}

getStartOffsets()
{
  local image="$1"
  local value=$(fdisk -l -o Start,Type "$image" | grep Linux | awk '{print $1}')
  echo $value
}

getAvailableSpace()
{
  local path="$1"
  local value=$(df -P "$path" | awk 'NR==2 {print $4}')
  echo $value
}

getEndSector()
{
  local image="$1"
  local value=$(fdisk -o End -l "$image" | tail -1)
  echo $(trim "$value")
}

hasGptLayout()
{
  local image="$1"
  if $(fdisk -l "$image" 2>/dev/null | grep -q 'type: gpt'); then
    echo true
  else
    echo false
  fi
}

trim() {
  local string="$*"
  local string="${string#"${string%%[![:space:]]*}"}"
  local string="${string%"${string##*[![:space:]]}"}"   
  printf '%s' "$string"
}


#===========================================

(return 0 2>/dev/null) || main "$@"
